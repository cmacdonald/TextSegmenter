PARSER_BEGIN(UQLParser)package it.cnr.isti.hpclab.query;
import it.unimi.dsi.fastutil.objects.ObjectArrayList;public class UQLParser{    private final static boolean DEBUG = false;        public UQLParser()     {        this( new java.io.StringReader( "" ) ); // Just for initialization purposes...     }    public Query parse( final String text ) throws QueryParserException    {        ReInit( new java.io.StringReader( text ) );					try {			final Query query = query();				return query;		} catch( ParseException e ) {			throw new QueryParserException( e );		}	}	       public static void main(String args[])    {        try        {            String query = args[0];            UQLParser parser = new UQLParser();            System.err.println(parser.parse(query));        }        catch(Exception e)        {            e.printStackTrace();        }    }}PARSER_END(UQLParser) 
/** Skip these characters, they are considered "white space" **/SKIP :                              {      " "    | "\t"    | "\r"    | "\n"}/** Reserved tokens for UQL */TOKEN :{      <AND: "&">   |  <OR:  "|">   |  <OPEN_PAREN: "(">   |  <CLOSE_PAREN: ")">}/** The terms */TOKEN : {      < WORD : (["A"-"Z","a"-"z","0"-"9"])+ >}/** Top level */Query query() :{	Query query;}{		query = orQuery()	<EOF>	{		return query;	}}/** *  Starting rule for a OR-query.  *  @return the result of the query. */Query orQuery():{ 	Query res;	ObjectArrayList<Query> qrm = new ObjectArrayList<Query>(); }{	res = andQuery()	{ if ( DEBUG ) System.err.println( "Building OR query" ); }	{ qrm.add( res ); }	(		<OR>		res = andQuery()		{ if ( DEBUG ) System.err.println( "Building OR query" ); }		{   qrm.add( res ); }	)*		{ 		if ( qrm.size() == 1 ) return res;		return new Or( qrm.toArray( Queries.EMPTY_ARRAY ) );	}}/** *  Starting rule for an AND-query.  *  @return the result of the query. */Query andQuery():{ 	Query res;	ObjectArrayList<Query> qrm = new ObjectArrayList<Query>(); }{	res = singleTermQuery()	{ if ( DEBUG ) System.err.println( "Building AND query: " + res ); }	{ qrm.add( res ); }	(		<AND>		res = singleTermQuery()		{ if ( DEBUG ) System.err.println( "Building AND query: " + res ); }		{ qrm.add( res ); }	)*		{ 		if ( qrm.size() == 1 ) return res;		return new And( qrm.toArray( Queries.EMPTY_ARRAY ) );	}}/** Starting rule for an atomic simple query. May be either a word or a query *   enclosed within parentheses. *   @param indexAlias the index alias for the default index to be used for the query that is going to be parsed. *   @return the result of the query. */Query singleTermQuery():{	Query res;	Token t = null, s = null, p = null;}{	(		t = <WORD>		{ 			String word = t.image;			res = new Term( word );		}	|		<OPEN_PAREN> res = orQuery() <CLOSE_PAREN>	)	{		return res;	}}